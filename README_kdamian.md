# kdamian_TOC_project01

Team name: kdamian

Names of all team members: Kaia Damian

Link to github repository: https://github.com/kaiadamian/kdamian_TOC_project01.git

Which project options were attempted: 2-SAT DPLL Solver 

Approximately total time spent on project: 15 hours 

The language you used, and a list of libraries you invoked: Used Python language; invoked csv, time, and typing libraries.

How would a TA run your program (did you provide a script to run a test case?): The TA would type in ./dpll_kdamian.py to the command line, since I made the code executable. I hard-coded the check-kdamian.py test case file (which I copied from Professor Kogge’s 2SAT test file) into the dpll_kdamian.py program under the variable name “file,” so these test cases are read into the program and evaluated.

A brief description of the key data structures you used, and how the program functioned: I first read in the .csv file, saving the clauses into a List[List[int]] data structure, where each individual clause is a list of ints. I also initialized an assignments List[bool] where each index corresponds to a variable (its index would be variable-1), and the value in the list corresponds to the value (True, False, or None) of the variable. Once all the clauses are read in, I call dpll_algorithm on clauses and assignments. In dpll_algorithm, I first check if any clauses are of length 1; if there are, I call unit_propagation on clauses and assignments. In unit propagation, I find all of the clauses of length 1 and add them to a list called units. Then for every unit, it assigns that unit the truth value necessary to make that clause True and then removes every clause that that unit appears in (since the clause will be True). If -unit appears in any clause, then -unit is removed from that clause (since we need to find the truth value of the other literal in the clause in order to determine if the clause is satisfiable). Back in dpll_algorithm, after unit_propagation is called, pure_literal_elimination is called on clauses and assignments. In pure_literal_elimination, we find every pure literal (a literal in which its negation never appears in any of the clauses) by first adding every variable to a list then, if its negation is not in that list, it is added to the pure_literals set. Then, I delete every clause that the pure literal appears in (since the clause will be True). Back in dpll_algorithm, it now checks if there are any clauses left in clauses. If none are left, that means that all of them have been evaluated as True and deleted—thus, we return True. It then checks if there is any clause of length 0, which means that this clause is unsatisfiable—thus, we return False. After those checks, we choose the next literal to evaluate, which is clauses[0][0] by default. Then, we recursively call dpll_algorithm on clauses AND literal or dpll_algorithm on clauses AND -literal. This forces unit propagation on both possible truth values assigned to literal. If neither of these possible truth values eventually leads to a satisfaction, the algorithm returns False.

A discussion as to what test cases you added and why you decided to add them (what did they tell you about the correctness of your code). Where did the data come from? (course website, handcrafted, a data generator, other): I have the test case file check-kdamian.csv and data_kdamian.csv, which are both a copy of Professor Kogge’s 2SAT.cnf.csv file from the course website. I just copied it into data_kdamian.csv to follow the naming conventions required of this project, since I used this file when generating my timings. I decided to add the check-kdamian.csv test file so that I could have a large scale of test problems with which I could test my code. I evaluated a random selection of 10 of them manually, and my output matched that of my code. Thus, I can assume that my code is correct. Also, when I was first writing my code and I needed to add multiple print statements to see if it was working correctly, I added two problems to the check-sample-kdamian.csv file in order not to overwhelm myself with output. The first problem I got from the course website, the second I did by hand. Once my print statements showed that my problem was working correctly for these two problems, I ran my program on the check-kdamian.csv file, which also showed that my program was running correctly.

An analysis of the results, such as if timings were called for, which plots showed what? What was the approximate complexity of your program?: The plot plots_kdamian.png shows the timing analysis for the 100 problems I evaluated in the data_kdamian.csv file. The x-axis is the number of literals, and the y-axis is the time in seconds. Unsatisfiable points are red, and the satisfiable points are green. The bounding curve for worst case execution time (unsatisfiable problems) is shown in blue. Its approximate formula as well as its R2 value are shown on the right. The approximate time complexity of the DPLL algorithm is O(2v), but for 2-SAT, it is expected that most cases are more linear, and the worst case is almost linear or O(v).

A description of how you managed the code development and testing: I started off with this project by first looking up the DPLL algorithm as recommended by the instructor. I found wikipedia as a good and in-depth resource. Then, I wrote the main function to read in the csv file. Once I understood the unit propagation function as well as the pure literal elimination function, I wrote those and tested them with the check-sample-kdamian.csv file. Once I was confident that these functions were working, I wrote the dpll algorithm function using the wikipedia pseudocode as a reference, then tested it on the same check-sample-kdamian.csv file. Once I was confident that everything was working, I ran the program on the check-kdamian.csv file, manually evaluated about 10 of them, and then verified that my output and the output of the program matched up.

Did you do any extra programs, or attempted any extra test cases: The only extra test cases I developed was the check-sample-kdamian.csv file that I mentioned earlier, which contained one problem from the course website and one problem that I wrote myself and verified manually. Other than that, I just used the 2SAT test case file from the course website, which I mentioned earlier that I copied into the check-kdamian.csv file as well as the data_kdamian.csv file and used to verify my output as well as generate my timings.